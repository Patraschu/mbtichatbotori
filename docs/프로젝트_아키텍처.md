# MBTI ChatBot 시스템 아키텍처

## 🏗 아키텍처 개요

MBTI ChatBot은 Next.js 기반의 풀스택 웹 애플리케이션으로, 서버리스 아키텍처를 채택하여 확장성과 비용 효율성을 극대화했습니다.

### 핵심 기술 스택

| 레이어 | 기술 | 버전 | 용도 |
|--------|------|------|------|
| **Frontend** | Next.js | 15.4.2 | React 프레임워크 |
| **UI Library** | React | 19.1.0 | UI 컴포넌트 |
| **Language** | TypeScript | 5.6.3 | 타입 안정성 |
| **Styling** | Tailwind CSS | 3.4.17 | 유틸리티 CSS |
| **UI Components** | Radix UI | Latest | 접근성 컴포넌트 |
| **AI Engine** | Google Gemini | 2.0 Flash | 대화 생성 |
| **Database** | PostgreSQL | - | 데이터 저장 (준비) |
| **ORM** | Drizzle/Prisma | Latest | DB 추상화 |
| **Hosting** | Vercel | - | 서버리스 배포 |

## 🔄 시스템 플로우

```mermaid
graph TD
    A[사용자] -->|1. 설정 선택| B[Setup Page]
    B -->|2. MBTI/성별/관계| C[Chat Page]
    C -->|3. 메시지 입력| D[ChatInterface]
    D -->|4. API 요청| E[/api/chat]
    E -->|5. 페르소나 로드| F[MBTI Data]
    E -->|6. AI 요청| G[Gemini API]
    G -->|7. 응답 생성| E
    E -->|8. 응답 반환| D
    D -->|9. UI 업데이트| C
    C -->|10. 메시지 표시| A
```

## 📁 계층별 아키텍처

### 1. Presentation Layer (프레젠테이션 계층)

#### 주요 컴포넌트
- **SetupWizard**: 사용자 설정 수집 (MBTI, 성별, 관계)
- **ChatInterface**: 채팅 로직 및 상태 관리
- **ModernChatUI**: 카카오톡 스타일 UI 렌더링
- **ChatBubble**: 개별 메시지 표시

#### 상태 관리
```typescript
// 로컬 상태 (React State)
- messages: ChatMessage[]      // 대화 내역
- isTyping: boolean           // 타이핑 표시
- chatConfig: ChatbotConfig   // 챗봇 설정

// 세션 스토리지
- sessionId: string           // 세션 식별자
- lastActivity: Date          // 마지막 활동 시간
```

### 2. Application Layer (애플리케이션 계층)

#### API Routes
```
/api/chat
  └── POST: 메시지 전송 및 AI 응답 받기
      - Request: { message, config, sessionId }
      - Response: { text, sessionId }
  
/api/chat/test
  └── GET: API 키 유효성 검증
      - Response: { status, message }
```

#### 비즈니스 로직
- **세션 관리**: 메모리 기반 세션 스토어
- **Rate Limiting**: 세션당 요청 제한
- **메시지 분할**: [SPLIT] 태그 기반 분할
- **시간 인식**: KST 기준 시간대별 응답

### 3. Data Layer (데이터 계층)

#### 현재 구조
```
src/data/mbti/
├── INTJ.md    # 각 MBTI 유형별
├── INTP.md    # 페르소나 정의
├── ENTJ.md    # 마크다운 파일
└── ... (16개 파일)
```

#### 데이터 스키마 (준비 중)
```typescript
// Drizzle ORM Schema
export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: varchar('email', { length: 255 }).unique().notNull(),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow()
});

export const chatRooms = pgTable('chat_rooms', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').references(() => users.id),
  mbti: varchar('mbti', { length: 4 }).notNull(),
  gender: varchar('gender', { length: 10 }),
  relationship: varchar('relationship', { length: 20 }),
  createdAt: timestamp('created_at').defaultNow(),
  lastMessageAt: timestamp('last_message_at'),
  isActive: boolean('is_active').default(true)
});

export const messages = pgTable('messages', {
  id: uuid('id').primaryKey().defaultRandom(),
  roomId: uuid('room_id').references(() => chatRooms.id),
  content: text('content').notNull(),
  sender: varchar('sender', { length: 10 }).notNull(),
  timestamp: timestamp('timestamp').defaultNow(),
  isRead: boolean('is_read').default(false)
});
```

## 🔐 보안 아키텍처

### API 보안
1. **환경 변수 관리**
   - API 키는 서버 사이드에서만 접근
   - `.env.local`로 로컬 개발
   - Vercel 환경 변수로 프로덕션 관리

2. **Rate Limiting**
   ```typescript
   // 세션별 제한
   - 블로킹 시간: 2-5분
   - 세션 자동 정리: 30분
   ```

3. **입력 검증**
   - XSS 방지: React 자동 이스케이핑
   - 메시지 길이 제한
   - MBTI 타입 검증

### 데이터 보안
- HTTPS 전송 암호화
- 세션 데이터 메모리 저장 (임시)
- 민감 정보 로깅 금지

## 🚀 배포 아키텍처

### Vercel 서버리스 구조
```
┌─────────────────────────────────────┐
│           Vercel Edge Network        │
├─────────────────────────────────────┤
│         Next.js Application         │
├──────────────┬──────────────────────┤
│   Static     │   Serverless        │
│   Assets     │   Functions         │
│              │                      │
│  - HTML/CSS  │  - API Routes       │
│  - JS Bundle │  - SSR Pages        │
│  - Images    │  - Middleware       │
└──────────────┴──────────────────────┘
```

### 장점
1. **자동 스케일링**: 트래픽에 따른 자동 확장
2. **글로벌 CDN**: 전 세계 엣지 로케이션
3. **Zero Config**: 별도 서버 설정 불필요
4. **Git 통합**: Push 시 자동 배포

## 📊 성능 최적화

### Frontend 최적화
1. **코드 스플리팅**
   - Next.js 자동 코드 분할
   - 동적 import로 번들 크기 감소

2. **이미지 최적화**
   - Next/Image 컴포넌트 사용
   - WebP 자동 변환

3. **캐싱 전략**
   - 정적 자산 브라우저 캐싱
   - API 응답 캐싱 (준비 중)

### Backend 최적화
1. **서버리스 최적화**
   - Cold Start 최소화
   - 함수 크기 최적화

2. **AI 응답 최적화**
   - 스트리밍 응답 (구현 예정)
   - 토큰 제한 관리

## 🔄 확장 계획

### Phase 1: MVP (현재)
- ✅ 기본 채팅 기능
- ✅ MBTI 페르소나
- ✅ 세션 기반 대화
- ✅ Vercel 배포

### Phase 2: 데이터 영속성
- 🔲 사용자 인증 (NextAuth.js)
- 🔲 PostgreSQL 통합
- 🔲 대화 기록 저장
- 🔲 채팅방 관리

### Phase 3: 고급 기능
- 🔲 실시간 기능 (WebSocket)
- 🔲 음성 대화 지원
- 🔲 이미지 생성/인식
- 🔲 다국어 지원 확대

### Phase 4: 분석 및 개인화
- 🔲 대화 분석 대시보드
- 🔲 사용자별 선호도 학습
- 🔲 맞춤형 응답 생성
- 🔲 A/B 테스팅

## 🏛 아키텍처 원칙

### 1. 단순성 우선
- 불필요한 복잡도 제거
- 명확한 책임 분리
- 직관적인 코드 구조

### 2. 확장 가능성
- 모듈화된 컴포넌트
- 느슨한 결합
- 인터페이스 기반 설계

### 3. 성능 중심
- 빠른 응답 시간
- 효율적인 리소스 사용
- 사용자 경험 최적화

### 4. 보안 우선
- 최소 권한 원칙
- 데이터 암호화
- 정기적인 보안 점검

## 📈 모니터링 및 로깅

### 현재 구현
- Vercel Analytics: 성능 메트릭
- Console 로깅: 개발 디버깅

### 구현 예정
- Sentry: 에러 트래킹
- Datadog: APM 모니터링
- Custom Analytics: 사용자 행동 분석

## 🔧 개발 환경

### 로컬 개발
```bash
# 개발 서버 실행
npm run dev

# 타입 체크
npm run type-check

# 빌드 테스트
npm run build
```

### CI/CD 파이프라인
1. GitHub Push
2. Vercel 자동 빌드
3. Preview 배포
4. 프로덕션 배포 (main 브랜치)

## 📝 아키텍처 결정 기록 (ADR)

### ADR-001: Next.js 선택
- **결정**: Next.js 15 App Router 사용
- **이유**: 
  - React 최신 기능 지원
  - 서버/클라이언트 통합
  - Vercel 최적화
- **대안**: Remix, Gatsby, CRA
- **결과**: 개발 속도 향상, 배포 간소화

### ADR-002: Gemini AI 선택
- **결정**: Google Gemini 2.0 Flash 사용
- **이유**:
  - 빠른 응답 속도
  - 한국어 성능 우수
  - 비용 효율적
- **대안**: OpenAI GPT-4, Claude, Llama
- **결과**: 자연스러운 한국어 대화 구현

### ADR-003: 서버리스 아키텍처
- **결정**: Vercel 서버리스 플랫폼
- **이유**:
  - 자동 스케일링
  - 비용 효율성
  - 관리 부담 최소화
- **대안**: AWS Lambda, Railway, Heroku
- **결과**: 운영 부담 감소, 비용 절감

---

> 📌 **Note**: 이 문서는 시스템 아키텍처가 변경될 때마다 업데이트되어야 합니다.